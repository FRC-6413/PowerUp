// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc6413.SteamWorks.subsystems;

import java.math.BigDecimal;
import java.math.RoundingMode;

import org.usfirst.frc6413.SteamWorks.RobotMap;
import org.usfirst.frc6413.SteamWorks.commands.*;

import com.ctre.CANTalon;
import com.ctre.CANTalon.TalonControlMode;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class DriveBase extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon lFM = RobotMap.driveBaseLFM;
	private final CANTalon lRM = RobotMap.driveBaseLRM;
	private final CANTalon rFM = RobotMap.driveBaseRFM;
	private final CANTalon rRM = RobotMap.driveBaseRRM;
	private final RobotDrive robotDrive41 = RobotMap.driveBaseRobotDrive41;
	//private final AnalogInput rearUltrasonic = RobotMap.driveBaseRearUltrasonic;
	private final AnalogInput frontUltrasonic = RobotMap.driveBaseFrontUltrasonic;

	private int loops = 0;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private final AHRS ahrs = RobotMap.ahrs;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new MecanumDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void mecanumDrive(XboxController controller) {		
	  double x = deadZoneInput(controller.getX(GenericHID.Hand.kLeft), .3); 
	  double y = deadZoneInput(controller.getY(GenericHID.Hand.kLeft), .1) * .5; 
	  double rotation = deadZoneInput(controller.getX(GenericHID.Hand.kRight), .1) * .7;
	  
	  if(controller.getTriggerAxis(GenericHID.Hand.kRight) != 0.0) {
			double trigger = controller.getTriggerAxis(GenericHID.Hand.kRight);
			y = y * (trigger + 1);
			rotation = rotation * (1-(trigger*.5));
	  }
		  
		StringBuilder sb = new StringBuilder();
		
		if(controller.getBumper(GenericHID.Hand.kLeft)) {
			rFM.changeControlMode(TalonControlMode.PercentVbus);
			rRM.changeControlMode(TalonControlMode.PercentVbus);
			lFM.changeControlMode(TalonControlMode.PercentVbus);
			lRM.changeControlMode(TalonControlMode.PercentVbus);
			
			robotDrive41.mecanumDrive_Cartesian(x, y, rotation, 0);		
		}
		else {
			y = y * -1;
			//sb.append("rawx:" + rotation + ", rawy:" + y);
			//double motorOutput = lFM.getOutputVoltage() / lFM.getBusVoltage();
			
			double z = Math.sqrt(rotation * rotation + y * y);
			double rad = Math.acos(Math.abs(rotation)/z);
			double angle = rad * 180.0 / Math.PI;
			
			double tcoeff = -1 + (angle/90.0)*2.0;
			double turn = tcoeff * Math.abs(Math.abs(y) - Math.abs(rotation));
			turn = Math.round(turn*100.0)/100.0;
			
			double move = Math.max(Math.abs(y), Math.abs(rotation));
			
			double left = 0;
			double right = 0;
			
			if ((rotation >= 0 && y >=0) || (rotation < 0 && y < 0))
			{
				left = move;
				right = turn;				
			}
			else {
				right = move;
				left = turn;								
			}
			
			if (y < 0)
			{
				left = 0 - left;
				right = 0 - right;				
			}
			
			double rightTargetSpeed = right * 1200;
	    	rFM.changeControlMode(TalonControlMode.Speed);
	    	rFM.set(rightTargetSpeed);
	    	
	    	//rRM.changeControlMode(TalonControlMode.Follower);
	    	//rRM.set(0);
	    	
	    	rRM.changeControlMode(TalonControlMode.Speed);
	    	rRM.set(rightTargetSpeed);
	    	
	    	double leftTargetSpeed = left * 1200;
	    	lFM.changeControlMode(TalonControlMode.Speed);
	    	lFM.set(leftTargetSpeed);
	    	
	    	//lRM.changeControlMode(TalonControlMode.Follower);
	    	//lRM.set(1);
	    	
	    	lRM.changeControlMode(TalonControlMode.Speed);
	    	lRM.set(leftTargetSpeed);	    	
		}
	}

	public void driveCount() {
		lFM.changeControlMode(TalonControlMode.Position);
		lFM.set(1000);
	}
	
	public void driveForward(double speed) {
		// need to reverse the right side, due to setup of mecanum drive
		lFM.changeControlMode(TalonControlMode.PercentVbus);
		lFM.set(speed);
		
		rFM.changeControlMode(TalonControlMode.PercentVbus);
		rFM.set(speed);
		
		lRM.changeControlMode(TalonControlMode.PercentVbus);
		lRM.set(speed);
		
		rRM.changeControlMode(TalonControlMode.PercentVbus);
		rRM.set(speed);
	}

	//public double getDistanceBehind() {
	//	return rearUltrasonic.getAverageVoltage();
	//}

	public double getDistanceAhead() {
		return frontUltrasonic.getAverageVoltage();
	}

	public void rotateToDegree(double degree) {

	}

	public static double round(double value, int places) {
		if (places < 0)
			throw new IllegalArgumentException();

		BigDecimal bd = new BigDecimal(value);
		bd = bd.setScale(places, RoundingMode.HALF_UP);
		return bd.doubleValue();
	}

	private double deadZoneInput(double input, double deadZone) {
		if (input <= deadZone && input >= -deadZone)
			return 0;
		else if (input >= deadZone)
			input = ((input - deadZone) / (1 - deadZone));
		else if (input <= deadZone)
			input = ((-input - deadZone) / (deadZone - 1));

		return round(input, 2);
	}
}
